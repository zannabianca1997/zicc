descr: |
    Really inefficent fibo using calls. 
    Stress test the call stack and three variable calls

tests:
    one:
        in: [1, 1, 0]
        out: [1]
    two:
        in: [1, 1, 1]
        out: [1]
    three:
        in: [1, 1, 2]
        out: [2]
    five:
        in: [1, 1, 4]
        out: [5]
    ten:
        in: [1,1,10]
        out: [89]
    lucas:
        in: [2,1,10]
        out: [123]
---
fibo:
    /*
        stack is:
            -4: fibo(0), then the output value
            -3: fibo(1)
            -2: n
            -1: return address
    */
    // test for end cases 

    jnz @-2 #$0
        ret // the output fibo(0) is already in @-4
    $0:

    dec @-2
    jnz @-2 #$1
        inc @-2
        mov @-3 @-4 // move the output value
        ret
    $1:
    inc @-2


    /*
        Extending call frame to call recursively
        stack is:
            -8: fibo(0), then the output value
            -7: fibo(1)
            -6: n
            -5: return address
            -4: accumulator for the sum
            -3: fibo(0), then output value of the subroutine
            -2: fibo(1)
            -1: n-1 | n-2
    */
    incb #4

    mov #0 @-4 // zeroing the accumulator
    mov @-8 @-3 3 // moving all the parameters

    dec @-1 // now argument 3 is n-1
    call #fibo
    add @-3 @-4 @-4

    mov @-8 @-3 // resetting first argument
    dec @-1     // now argument 3 is n-2
    call #fibo
    add @-3 @-4 @-4 // actual sum

    mov @-4 @-8 // setting output

    incb #-4 // popping locals
    ret

entry main
main:
    /*
        local variables:
            -3: fibo(0)
            -2: fibo(1)
            -1: n
    */
    incb #3
    in @-3; in @-2;
    in @-1

    call #fibo

    out @-3

    incb #-3
    ret
